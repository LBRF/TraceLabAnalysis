### Physical tracing preprocessing and analysis functions for TraceLab ###


### Import required packages ###

library(tibble)
library(vegan)
library(dtw)



### Utility functions ###

# Calculates standard deviation of paired differences

paired.sd <- function(x) {
  SS <- sum(x ** 2)
  df <- length(x) - 1
  sqrt(SS / df)
}


# Reinterpolates a figure or tracing, either by time or by distance

reinterpolate <- function(x, y, time, equidistant = FALSE, fps = 60, n = NA) {

  # If equidistant, interpolate constant-velocity points along path. Otherwise,
  # use timestamps to generate points at same variable speed as input tracing.
  if (equidistant) {
    dists <- sqrt((x - lag(x))^2 + (y - lag(y))^2)
    dists[1] <- 0
    steps <- cumsum(dists)
  } else {
    steps <- time
  }

  # Figure out number of frames to generate based on tracing time and framerate,
  # unless number of frames is explicitly provided
  if (!is.na(n)) {
    out_num <- n
  } else {
    out_num <- round(max(time) / (1 / fps)) + 1 # add 1 because first time is 0
  }

  # Return new interpolated points
  interpolated <- tibble(
    x = approx(steps, x, n = out_num, method = "linear")$y,
    y = approx(steps, y, n = out_num, method = "linear")$y
  )

  interpolated
}


# Matches length of stimulus to response via reinterpolation

match_lengths <- function(x, y, tx, ty, equidist = FALSE) {

  # Get path lengths of stim and tracing
  stim_n <- max(which(!is.na(x)))
  trace_n <- max(which(!is.na(tx)))

  # Reinterpolate stim to make it equal to tracing in length
  stime <- seq(1, stim_n) * (1 / 60)
  newstim <- reinterpolate(x[!is.na(x)], y[!is.na(y)], stime, n = trace_n)
  matched_df <- tibble(
    x = newstim$x, y = newstim$y,
    trace.x = tx[!is.na(tx)], trace.y = ty[!is.na(ty)]
  )

  # If enabled, reinterpolate tracing so all points are equidistant
  if (equidist) {
    ttime <- seq(1, trace_n) * (1 / 60)
    newtrace <- reinterpolate(
      tx[!is.na(tx)], ty[!is.na(ty)],
      ttime, equidistant = TRUE, n = trace_n
    )
    matched_df$trace.x <- newtrace$x
    matched_df$trace.y <- newtrace$y
  }

  matched_df
}



### Transformation functions ###

procrustes2df <- function(x, y, tx, ty) {

  stim <- cbind(x, y)
  resp <- cbind(tx, ty)

  # Do procrustes transformation and get translated dataframe
  proc <- procrustes(stim, resp, scale = TRUE, symmetric = FALSE)
  proc_mat <- predict(proc, resp)
  proc_df <- as_tibble(proc_mat, .name_repair = ~ c("proc.x", "proc.y"))

  # Bind stim columns to procrustes data
  proc_df <- add_column(proc_df, x = x, .before = 1)
  proc_df <- add_column(proc_df, y = y, .before = 2)

  # Get procrustes metrics and add to dataframe
  proc_dx <- proc$xmean[1] - mean(tx)
  proc_dy <- proc$xmean[2] - mean(ty)
  proc_df$translation <- sqrt(proc_dx ** 2 + proc_dy ** 2)
  proc_df$scale <- proc$scale
  proc_df$rotation <- acos(proc$rotation[1, 1])

  proc_df
}

dtw2df <- function(x, y, tx, ty, step = mori2006) {
  
  # Do dynamic time warping and get warped dataframe
  tryCatch({
    warped <- dtw(
      x = cbind(tx[!is.na(tx)], ty[!is.na(ty)]),
      y = cbind(x[!is.na(x)], y[!is.na(y)]),
      dist.method = "Euclidean",
      step.pattern = step,
      window.type = "none",
      keep.internals = TRUE,
      distance.only = FALSE,
      open.end = FALSE,
      open.begin = FALSE
    )
    
    # Return dataframe with warped stimulus and response points
    dtw_df <- tibble(
      x_w = x[warped$index2],
      y_w = y[warped$index2],
      trace.x_w = tx[warped$index1],
      trace.y_w = ty[warped$index1]
    )
    
    dtw_df
  },
  error = function(x) {
    tibble(
      x_w = numeric(0),
      y_w = numeric(0),
      trace.x_w = numeric(0),
      trace.y_w = numeric(0)
    )
  })
}

dtw2df2 <- function(
    x, y, tx, ty, step = mori2006, open_ends = FALSE, absolute = FALSE, upsample = 1
) {
  
  if (upsample > 1) {
    tmp <- reinterpolate(x, y, NA, TRUE, n = round(length(x) * upsample))
    x <- tmp$x
    y <- tmp$y
  }
  
  time <- 1:length(x) * (1 / 60)
  delt <- get_angle_diffs(x, y)
  tdelt <- get_angle_diffs(tx, ty)
  
  d1 <- scale(tdelt[!is.na(tdelt)])
  d2 <- scale(delt[!is.na(delt)])
  if (absolute) {
    d1 <- abs(d1)
    d2 <- abs(d2)
  }
  
  # Do dynamic time warping and get warped dataframe
  warped <- dtw(
    x = d1,
    y = d2,
    step.pattern = step,
    window.type = "none",
    keep.internals = TRUE,
    distance.only = FALSE,
    open.end = open_ends,
    open.begin = open_ends
  )
  
  # Return dataframe with warped stimulus and response points
  dtw_df <- tibble(
    tw = time[warped$index2],
    x = x[warped$index2],
    y = y[warped$index2],
    delta = na.omit(delt)[warped$index2],
    ttw = time[warped$index1],
    tx = tx[warped$index1],
    ty = ty[warped$index1],
    tdelta = na.omit(tdelt)[warped$index1]
  ) %>%
  mutate(time = 1:n() * (1 / 60))
  
  dtw_df
}
